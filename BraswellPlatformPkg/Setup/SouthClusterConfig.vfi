// /** @file
//  Driver Setup formset.
//
//  Copyright (c) 2004 - 2015, Intel Corporation. All rights reserved.<BR>
//
//  This program and the accompanying materials
//  are licensed and made available under the terms and conditions of the BSD License
//  which accompanies this distribution.  The full text of the license may be found at
//  http://opensource.org/licenses/bsd-license.php.
//
//  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
//  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
//
// **/

//
// South Cluster Configuration Form
//

form formid = SOUTH_CLUSTER_FORM_ID,
  title    = STRING_TOKEN(STR_SOUTH_CLUSTER_TITLE);

  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  //
  // Jump to Azalia Configuration Form
  //
  goto AZALIA_OPTIONS_FORM_ID,
    prompt = STRING_TOKEN(STR_AZALIA_OPTIONS_FORM_TITLE),
    help   = STRING_TOKEN(STR_AZALIA_OPTIONS_FORM_HELP);


  //
  // Jump to LPSS Configuration Form
  //
  goto LPSS_OPTIONS_FORM_ID,
    prompt = STRING_TOKEN(STR_LPSS_FORM_TITLE),
    help   = STRING_TOKEN(STR_LPSS_FORM_HELP);

#ifdef PCIESC_SUPPORT
  //
  // Jump to PCIe Configuration Form
  //
  goto PCIE_DEVICE_OPTIONS_FORM_ID,
    prompt = STRING_TOKEN(STR_PCIE_OPTIONS_FORM_TITLE),
    help = STRING_TOKEN(STR_PCIE_OPTIONS_FORM_HELP);
#endif

#ifdef SATA_SUPPORT
  //
  // Jump to SATA Configuration Form
  //
  goto SATA_OPTIONS_FORM_ID,
    prompt = STRING_TOKEN(STR_SATA_DEVICE_OPTIONS_FORM_TITLE),
    help   = STRING_TOKEN(STR_SATA_DEVICE_OPTIONS_FORM_HELP);
#endif
  //
  // Jump to SCC Configuration Form
  //
  goto SCC_OPTIONS_FORM_ID,
    prompt = STRING_TOKEN(STR_SCC_OPTIONS_FORM_TITLE),
    help   = STRING_TOKEN(STR_SCC_OPTIONS_FORM_HELP);

  //
  // Jump to USB Configuration Form
  //
  goto USB_OPTIONS_FORM_ID,
    prompt = STRING_TOKEN(STR_USB_OPTIONS_FORM_TITLE),
    help = STRING_TOKEN(STR_USB_OPTIONS_FORM_HELP);

  //
  // Jump to ISCT Configuration Form
  //
  goto ISCT_CONFIGURATION_ID,
    prompt = STRING_TOKEN(STR_ISCT_FORM_TITLE),
    help   = STRING_TOKEN(STR_ISCT_FORM_HELP);

  //
  // Jump to Security Configuration Form
  //
  goto SECURITY_OPTIONS_FORM_ID,
    prompt = STRING_TOKEN(STR_SECURITY_OPTIONS_FORM_TITLE),
    help = STRING_TOKEN(STR_SECURITY_OPTIONS_FORM_HELP);

  //
  // Jump to PSS Chip Form
  //
    
  //
  // Jump to Misc Configuration Form
  //
  goto MISC_OPTIONS_FORM_ID,
    prompt = STRING_TOKEN(STR_MISC_OPTION_FORM_TITLE),
    help   = STRING_TOKEN(STR_MISC_OPTION_FORM_HELP);
endform;

//
// Misc Configurations
//
form formid     = MISC_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_MISC_OPTION_FORM_TITLE);
  subtitle text = STRING_TOKEN(STR_MISC_OPTION_FORM_TITLE);


  oneof varid   = Setup.Hpet,
    prompt      = STRING_TOKEN(STR_HPET_PROMPT),
    help        = STRING_TOKEN(STR_HPET_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags =  RESET_REQUIRED;
  endoneof;
  

  oneof varid   = Setup.StateAfterG3,
    prompt      = STRING_TOKEN(STR_STATE_AFTER_G3),
    help        = STRING_TOKEN(STR_STATE_AFTER_G3_HELP),
    option text = STRING_TOKEN(STR_S0_AFTER_G3_STRING), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_S5_AFTER_G3_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;

  oneof varid   = Setup.EnableClockSpreadSpec,
    prompt      = STRING_TOKEN(STR_CLOCK_SPREAD_SPEC_ENABLE),
    help        = STRING_TOKEN(STR_CLOCK_SPREAD_SPEC_ENABLE_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
  endoneof;
  
  
//  oneof varid   = Setup.EnableSataClockSpreadSpec,
//    prompt      = STRING_TOKEN(STR_SATA_CLOCK_SPREAD_SPEC_ENABLE),
//    help        = STRING_TOKEN(STR_SATA_CLOCK_SPREAD_SPEC_ENABLE_HELP),
//    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
//    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
//  endoneof;


  oneof varid = Setup.MmioSize,
    prompt         = STRING_TOKEN(STR_MMIO_PROMPT),
    help           = STRING_TOKEN(STR_MMIO_HELP),
#if defined (MDE_CPU_IA32)
    option text    = STRING_TOKEN(STR_MMIO_0_75G_STRING), value = 0, flags = RESET_REQUIRED;
    option text    = STRING_TOKEN(STR_MMIO_1G_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text    = STRING_TOKEN(STR_MMIO_1_25G_STRING), value = 2, flags = RESET_REQUIRED;
    option text    = STRING_TOKEN(STR_MMIO_1_5G_STRING), value = 3, flags = RESET_REQUIRED;
    option text    = STRING_TOKEN(STR_MMIO_2G_STRING), value = 4, flags = RESET_REQUIRED;
#else
    option text    = STRING_TOKEN(STR_MMIO_0_75G_STRING), value = 0, flags = RESET_REQUIRED;
    option text    = STRING_TOKEN(STR_MMIO_1G_STRING), value = 1, flags = RESET_REQUIRED;
    option text    = STRING_TOKEN(STR_MMIO_1_25G_STRING), value = 2, flags = RESET_REQUIRED;
    option text    = STRING_TOKEN(STR_MMIO_1_5G_STRING), value = 3, flags = RESET_REQUIRED;
    option text    = STRING_TOKEN(STR_MMIO_2G_STRING), value = 4, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
#endif
  endoneof;

endform; // Enf of Misc Configurations


//
// ISCT Configuration
//
form formid = ISCT_CONFIGURATION_ID,

  title    = STRING_TOKEN(STR_ISCT_FORM_TITLE);

  subtitle text = STRING_TOKEN(STR_ISCT_FORM_TITLE);

  oneof varid   = Setup.IsctConfiguration,
    prompt      = STRING_TOKEN(STR_ISCT_CONFIGURATION),
    help        = STRING_TOKEN(STR_ISCT_CONFIGURATION_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value=0, flags= DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value=1, flags= RESET_REQUIRED;
  endoneof;

  suppressif ideqval Setup.IsctConfiguration == 0;
    oneof varid = Setup.IsctNotificationControl,
      prompt   = STRING_TOKEN(STR_ISCT_NOTIFICATION_CONTROL_PROMPT),
      help     = STRING_TOKEN(STR_ISCT_NOTIFICATION_CONTROL_HELP),
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    endoneof;

    oneof varid = Setup.IsctWlanPowerControl,
      prompt   = STRING_TOKEN(STR_ISCT_WLAN_CONTROL_PROMPT),
      help     = STRING_TOKEN(STR_ISCT_WLAN_CONTROL_HELP),
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    endoneof;

    oneof varid = Setup.IsctWwanPowerControl,
      prompt   = STRING_TOKEN(STR_ISCT_WWAN_CONTROL_PROMPT),
      help     = STRING_TOKEN(STR_ISCT_WWAN_CONTROL_HELP),
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
    endoneof;

    oneof varid = Setup.IsctSleepDurationFormat,
      prompt   = STRING_TOKEN(STR_ISCT_SLEEP_DURATION_FORMAT),
      help     = STRING_TOKEN(STR_ISCT_SLEEP_DURATION_FORMAT_HELP),
      option text = STRING_TOKEN(STR_SECONDS), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
//      option text = STRING_TOKEN(STR_ACTUAL_TIME), value = 0, flags = RESET_REQUIRED;
    endoneof;

    oneof varid = Setup.IsctRFKillSupport,
      prompt   = STRING_TOKEN(STR_ISCT_RF_KILL_SUPPORT),
      help     = STRING_TOKEN(STR_ISCT_RF_KILL_SUPPORT_HELP),
      option text = STRING_TOKEN(STR_RF_KILL_SOFT), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_RF_KILL_PHYSICAL), value = 1, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

  endif;
 
endform;

//
// LPSS Configurations
//
form formid = LPSS_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_LPSS_FORM_TITLE);
  subtitle text = STRING_TOKEN(STR_LPSS_SETTING_SUBTITLE);

  oneof varid   = Setup.GpioAcpiEnabled,
    prompt      = STRING_TOKEN(STR_GPIO_ACPI_PROMPT),
    help        = STRING_TOKEN(STR_GPIO_ACPI_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;

  grayoutif ideqval Setup.GpioAcpiEnabled == 0;
  oneof varid   = Setup.LpssDma1Enabled,
    prompt      = STRING_TOKEN(STR_LPSS_DMA1_PROMPT),
    help        = STRING_TOKEN(STR_LPSS_DMA1_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;
  endif;

  grayoutif ideqval Setup.LpssDma1Enabled == 0 OR ideqval Setup.GpioAcpiEnabled == 0;
    oneof varid   = Setup.LpssI2C0Enabled,
      prompt      = STRING_TOKEN(STR_LPSS_I2C0_PROMPT),
      help        = STRING_TOKEN(STR_LPSS_I2C0_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.LpssI2C1Enabled,
      prompt      = STRING_TOKEN(STR_LPSS_I2C1_PROMPT),
      help        = STRING_TOKEN(STR_LPSS_I2C1_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.LpssI2C2Enabled,
      prompt      = STRING_TOKEN(STR_LPSS_I2C2_PROMPT),
      help        = STRING_TOKEN(STR_LPSS_I2C2_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.LpssI2C3Enabled,
      prompt      = STRING_TOKEN(STR_LPSS_I2C3_PROMPT),
      help        = STRING_TOKEN(STR_LPSS_I2C3_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

  suppressif ideqval Setup.BoardId == 0x44 OR ideqval Setup.BoardId == 0x80; // Refer BOARD_ID_BSW & BOARD_ID_BSW_CH in PlatformInfo.h
    oneof varid   = Setup.LpssI2C4Enabled,
      prompt      = STRING_TOKEN(STR_LPSS_I2C4_PROMPT),
      help        = STRING_TOKEN(STR_LPSS_I2C4_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

    oneof varid   = Setup.LpssI2C5Enabled,
      prompt      = STRING_TOKEN(STR_LPSS_I2C5_PROMPT),
      help        = STRING_TOKEN(STR_LPSS_I2C5_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.LpssI2C6Enabled,
      prompt      = STRING_TOKEN(STR_LPSS_I2C6_PROMPT),
      help        = STRING_TOKEN(STR_LPSS_I2C6_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  grayoutif ideqval Setup.GpioAcpiEnabled == 0;
  oneof varid   = Setup.LpssDma0Enabled,
    prompt      = STRING_TOKEN(STR_LPSS_DMA0_PROMPT),
    help        = STRING_TOKEN(STR_LPSS_DMA0_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;
  endif;

  grayoutif ideqval Setup.LpssDma0Enabled == 0 OR ideqval Setup.GpioAcpiEnabled == 0;

    oneof varid   = Setup.LpssHsuart0Enabled,
      prompt      = STRING_TOKEN(STR_LPSS_HSUART0_PROMPT),
      help        = STRING_TOKEN(STR_LPSS_HSUART0_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.LpssHsuart1Enabled,
      prompt      = STRING_TOKEN(STR_LPSS_HSUART1_PROMPT),
      help        = STRING_TOKEN(STR_LPSS_HSUART1_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

  endif;

  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  subtitle text = STRING_TOKEN(STR_I2C_DEVICE_SETTING_SUBTITLE);
 suppressif ideqval Setup.BoardId == 0x80; // Refer BOARD_ID_BSW_CH in PlatformInfo.h
  oneof varid   = Setup.I2CTouchAd,
    prompt      = STRING_TOKEN(STR_I2C_TOUCH_PROMPT),
    help        = STRING_TOKEN(STR_I2C_TOUCH_HELP_BSW),
    option text = STRING_TOKEN(STR_AUTO), value=0, flags=DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_I2C_FVP), value=0x4C, flags=0 | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_I2C_FFRD), value=0x4A, flags=0 | RESET_REQUIRED;
  endoneof;
 endif;
    
  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  subtitle text = STRING_TOKEN(STR_BTH_DEVICE_SETTING_SUBTITLE);

    oneof varid = Setup.BTModule,
      prompt      = STRING_TOKEN(STR_BTH_MODULE_PROMPT),
      help        = STRING_TOKEN(STR_BTH_MODULE_HELP),
      option text = STRING_TOKEN(STR_BTH_BCRM), value=1, flags=DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_BTH_STP), value=2, flags=RESET_REQUIRED;
      option text = STRING_TOKEN(STR_BTH_LNP), value=3, flags=RESET_REQUIRED;
    endoneof;

    suppressif ideqval Setup.BTModule == 2 OR ideqval Setup.BTModule == 3;
      oneof varid = Setup.BTHStatus,
      prompt      = STRING_TOKEN(STR_BTH_DEVICE_PROMPT),
      help        = STRING_TOKEN(STR_BTH_DEVICE_HELP),
      option text = STRING_TOKEN(STR_BTH_DEVICE1), value=1, flags=RESET_REQUIRED;
      option text = STRING_TOKEN(STR_BTH_DEVICE2), value=2, flags=RESET_REQUIRED;
      option text = STRING_TOKEN(STR_BTH_DEVICE4), value=4, flags=DEFAULT | RESET_REQUIRED;
      endoneof;
    endif;

  subtitle text = STRING_TOKEN(STR_NULL_STRING);
  subtitle text = STRING_TOKEN(STR_CAMERA_DEVICE_SETTING_SUBTITLE);	

    suppressif ideqval Setup.Ellensburg == 1;
      oneof varid   = Setup.RvpCameraDevSel,
        prompt      = STRING_TOKEN(STR_CAMERA_SELECTION_PROMPT),
        help        = STRING_TOKEN(STR_CAMERA_SELECTION_HELP),
        option text = STRING_TOKEN(STR_CYNTHIANA_A), value=0, flags=0 | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_CRD_B_V2_X), value=1, flags=DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

    suppressif ideqval Setup.Ellensburg == 0;
      oneof varid   = Setup.EbCameraDevSel,
        prompt      = STRING_TOKEN(STR_COMBO_AIC_PROMPT),
        help        = STRING_TOKEN(STR_COMBO_AIC_HELP),
        option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLE), value=1, flags=DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;

suppressif ideqval Setup.BoardId == 0x1 OR ideqval Setup.BoardId == 0x9 OR ideqval Setup.BoardId == 0xA; // For CHT CR, HR RVP and HR FFD
  subtitle text = STRING_TOKEN(STR_NULL_STRING);
  subtitle text = STRING_TOKEN(STR_NFC_DEVICE_SETTING_SUBTITLE);
      oneof varid   = Setup.SecureNfc,
        prompt      = STRING_TOKEN(STR_SECURE_NFC_PROMPT),
        help        = STRING_TOKEN(STR_SECURE_NFC_HELP),
        option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLE), value=1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
 endif;


endform; // End of LPSS_OPTIONS_FORM_ID

form formid     = SCC_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_SCC_OPTIONS_FORM_TITLE);

  oneof varid   = Setup.ScceMMCEnabled,
    prompt      = STRING_TOKEN(STR_SCC_EMMC_PROMPT),
    help        = STRING_TOKEN(STR_SCC_EMMC_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;

  oneof varid   = Setup.SccSdioEnabled,
    prompt      = STRING_TOKEN(STR_SCC_SDIO_PROMPT),
    help        = STRING_TOKEN(STR_SCC_SDIO_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = RESET_REQUIRED;
  endoneof;

  oneof varid   = Setup.SccSdcardEnabled,
    prompt      = STRING_TOKEN(STR_SCC_SDCARD_PROMPT),
    help        = STRING_TOKEN(STR_SCC_SDCARD_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;
suppressif ideqval Setup.SccSdcardEnabled == 1;
  numeric varid = Setup.Sdcard1p8vSwitchingDelay,
    prompt      = STRING_TOKEN(STR_SDCARD_1P8V_SWITCHING_DELAY_PROMPT),
    help        = STRING_TOKEN(STR_SDCARD_1P8V_SWITCHING_DELAY_HELP),
    flags       = RESET_REQUIRED,
    minimum     = 0,
    maximum     = 999,
    step        = 0,   // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
    default     = 0,   // 0 ms by default
  endnumeric;
  numeric varid = Setup.Sdcard3p3vDischargeDelay,
    prompt      = STRING_TOKEN(STR_SDCARD_3P3V_DISCHARGE_DELAY_PROMPT),
    help        = STRING_TOKEN(STR_SDCARD_3P3V_DISCHARGE_DELAY_HELP),
    flags       = RESET_REQUIRED,
    minimum     = 0,
    maximum     = 999,
    step        = 0,   // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
    default     = 250, // 250 ms by default
  endnumeric;
endif;

  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  oneof varid   = Setup.EmmcRxTuningEnable,
    prompt      = STRING_TOKEN(STR_EMMC_RX_TUNING_ENABLE_PROMPT),
    help        = STRING_TOKEN(STR_EMMC_RX_TUNING_ENABLE_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = RESET_REQUIRED;
  endoneof;

  oneof varid   = Setup.EmmcTxTuningEnable,
    prompt      = STRING_TOKEN(STR_EMMC_TX_TUNING_ENABLE_PROMPT),
    help        = STRING_TOKEN(STR_EMMC_TX_TUNING_ENABLE_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE),  value = 1, flags = RESET_REQUIRED;
  endoneof;
  
  suppressif ideqval Setup.EmmcTxTuningEnable == 1 OR ideqval Setup.EmmcRxTuningEnable == 1;
    oneof varid   = Setup.EmmcDriverMode,
      prompt      = STRING_TOKEN(STR_EMMC_DRIVER_MODE_PROMPT),
      help        = STRING_TOKEN(STR_EMMC_DRIVER_MODE_HELP),
      option text = STRING_TOKEN(STR_EMMC_DRIVER_MODE_AUTO),  value = 0, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_EMMC_DRIVER_MODE_52MHZ), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_EMMC_DRIVER_MODE_26MHZ), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_EMMC_DRIVER_MODE_BASIC), value = 3, flags = RESET_REQUIRED;
    endoneof;
  endif;

  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  oneof varid   = Setup.LpssSdioMode,
    prompt      = STRING_TOKEN(STR_SCC_SDIO_MODE_PROMPT),
    help        = STRING_TOKEN(STR_SCC_SDIO_MODE_HELP),
    option text = STRING_TOKEN(STR_SDIO_DEFAULT_MODE), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_SDIO_DDR50_MODE), value= 2 , flags = RESET_REQUIRED;
  endoneof;

endform; // End of SCC_OPTIONS_FORM_ID

//
// PCIe Configurations
//
form formid     = PCIE_DEVICE_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_PCIE_OPTIONS_FORM_TITLE);
  subtitle text = STRING_TOKEN(STR_PCIE_OPTIONS_FORM_TITLE);

  goto PCH_PCIERP1_OPTIONS_FORM_ID,
       prompt = STRING_TOKEN(STR_PCH_PCIERP1_PROMPT),
       help = STRING_TOKEN(STR_PCH_PCIERP_HELP);

  goto PCH_PCIERP2_OPTIONS_FORM_ID,
       prompt = STRING_TOKEN(STR_PCH_PCIERP2_PROMPT),
       help = STRING_TOKEN(STR_PCH_PCIERP_HELP);

  goto PCH_PCIERP3_OPTIONS_FORM_ID,
       prompt = STRING_TOKEN(STR_PCH_PCIERP3_PROMPT),
       help = STRING_TOKEN(STR_PCH_PCIERP_HELP);


endform; //End of PCIE_DEVICE_OPTIONS_FORM_ID

//------------------------------------------------------------------------------------

form formid     = PCH_PCIERP1_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_PCH_PCIERP1_PROMPT);

  oneof varid   = Setup.PcieRootPortEn[OFFSET_0],
    prompt      = STRING_TOKEN(STR_PCH_PCIERP1_PROMPT),
    help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
#if PCIESC_SUPPORT
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
#else
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
#endif
  endoneof;

  suppressif ideqval Setup.PcieRootPortEn[OFFSET_0] == 0x0;
    oneof varid   = Setup.PcieRootPortAspm[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT0),
      help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),

      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_AUTOMATIC), value = 4, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortURE[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortFEE[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortNFE[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortCEE[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSFE[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSNE[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSCE[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortPMCE[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortESE[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_ESE_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_ESE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;


    oneof varid   = Setup.PcieRootPortSpeed[OFFSET_0],
      prompt      = STRING_TOKEN (STR_PCIE_SPEED_PROMPT0),
      help        = STRING_TOKEN (STR_PCIE_SPEED_HELP),
      option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortTHS[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT0),
      help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortL1SubStates[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT),
      help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),

      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortNccSsc[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_NCC_SSC_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_NCC_SSC_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortTxEqDeemphSelection[OFFSET_0],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_TXEQDEEMPH_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_TXEQDEEMPH_HELP),
      option text = STRING_TOKEN(STR_DEEMPH_6DB), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_DEEMPH_3P5DB), value = 1, flags = RESET_REQUIRED;
    endoneof;

    numeric varid = Setup.PcieExtraBusRsvd[OFFSET_0],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT0),
      help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
      minimum     = 0,
      maximum     = 7,
      step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 0,    // default no extra bus reserved
    endnumeric;

    numeric varid = Setup.PcieMemRsvd[OFFSET_0],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT0),
      help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
      minimum     = 1,
      maximum     = 20,
      step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 10,   // Default 10MB Memory Reserved
    endnumeric;

    numeric varid = Setup.PcieIoRsvd[OFFSET_0],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT0),
      help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
      minimum     = 4,
      maximum     = 20,
      step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 4,    // Default 4K IO Reserved
    endnumeric;

  endif;
endform; //End of PCH_PCIERP1_OPTIONS_FORM_ID

//------------------------------------------------------------------------------------

form formid       = PCH_PCIERP2_OPTIONS_FORM_ID,
  title           = STRING_TOKEN(STR_PCH_PCIERP2_PROMPT);

    oneof varid   = Setup.PcieRootPortEn[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP2_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
#if PCIESC_SUPPORT
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
#else
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
#endif
    endoneof;

  suppressif ideqval Setup.PcieRootPortEn[OFFSET_1] == 0x0;
    oneof varid   = Setup.PcieRootPortAspm[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT1),
      help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_AUTOMATIC), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortURE[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortFEE[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortNFE[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortCEE[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSFE[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSNE[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSCE[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortPMCE[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortESE[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_ESE_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_ESE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;


    oneof varid   = Setup.PcieRootPortSpeed[OFFSET_1],
      prompt      = STRING_TOKEN (STR_PCIE_SPEED_PROMPT1),
      help        = STRING_TOKEN (STR_PCIE_SPEED_HELP),
      option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortTHS[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT1),
      help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortL1SubStates[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT),
      help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
     option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
     option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortNccSsc[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_NCC_SSC_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_NCC_SSC_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortTxEqDeemphSelection[OFFSET_1],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_TXEQDEEMPH_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_TXEQDEEMPH_HELP),
      option text = STRING_TOKEN(STR_DEEMPH_6DB), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_DEEMPH_3P5DB), value = 1, flags = RESET_REQUIRED;
    endoneof;

    numeric varid = Setup.PcieExtraBusRsvd[OFFSET_1],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT1),
      help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
      minimum     = 0,
      maximum     = 7,
      step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 0,    // default no extra bus reserved
    endnumeric;

    numeric varid = Setup.PcieMemRsvd[OFFSET_1],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT1),
      help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
      minimum     = 1,
      maximum     = 20,
      step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 10,   // Default 10MB Memory Reserved
    endnumeric;

    numeric varid = Setup.PcieIoRsvd[OFFSET_1],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT1),
      help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
      minimum     = 4,
      maximum     = 20,
      step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 4,    // Default 4K IO Reserved
    endnumeric;

  endif;
endform; //End of PCH_PCIERP2_OPTIONS_FORM_ID

//------------------------------------------------------------------------------------

form formid       = PCH_PCIERP3_OPTIONS_FORM_ID,
  title           = STRING_TOKEN(STR_PCH_PCIERP3_PROMPT);

    oneof varid   = Setup.PcieRootPortEn[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP3_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
#if PCIESC_SUPPORT
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
#else
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
#endif
    endoneof;

  suppressif ideqval Setup.PcieRootPortEn[OFFSET_2] == 0x0;
    oneof varid   = Setup.PcieRootPortAspm[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT2),
      help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_AUTOMATIC), value = 4, flags =  RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortURE[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortFEE[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortNFE[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortCEE[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSFE[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSNE[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSCE[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortPMCE[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortESE[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_ESE_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_ESE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;


    oneof varid   = Setup.PcieRootPortSpeed[OFFSET_2],
      prompt      = STRING_TOKEN (STR_PCIE_SPEED_PROMPT2),
      help        = STRING_TOKEN (STR_PCIE_SPEED_HELP),
      option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortTHS[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT2),
      help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortL1SubStates[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT),
      help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
     option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
     option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortNccSsc[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_NCC_SSC_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_NCC_SSC_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortTxEqDeemphSelection[OFFSET_2],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_TXEQDEEMPH_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_TXEQDEEMPH_HELP),
      option text = STRING_TOKEN(STR_DEEMPH_6DB), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_DEEMPH_3P5DB), value = 1, flags = RESET_REQUIRED;
    endoneof;

    numeric varid = Setup.PcieExtraBusRsvd[OFFSET_2],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT2),
      help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
      minimum     = 0,
      maximum     = 7,
      step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 0,    // default no extra bus reserved
    endnumeric;

    numeric varid = Setup.PcieMemRsvd[OFFSET_2],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT2),
      help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
      minimum     = 1,
      maximum     = 20,
      step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 10,   // Default 10MB Memory Reserved
    endnumeric;

    numeric varid = Setup.PcieIoRsvd[OFFSET_2],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT2),
      help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
      minimum     = 4,
      maximum     = 20,
      step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 4,    // Default 4K IO Reserved
    endnumeric;

  endif;
endform; //End of PCH_PCIERP3_OPTIONS_FORM_ID

//------------------------------------------------------------------------------------

form formid       = PCH_PCIERP4_OPTIONS_FORM_ID,
  title           = STRING_TOKEN(STR_PCH_PCIERP4_PROMPT);

    oneof varid   = Setup.PcieRootPortEn[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIERP4_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIERP_HELP),
#if PCIESC_SUPPORT
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
#else
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
#endif
    endoneof;

  suppressif ideqval Setup.PcieRootPortEn[OFFSET_3] == 0x0;
    oneof varid   = Setup.PcieRootPortAspm[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCIE_ASPM_PROMPT3),
      help        = STRING_TOKEN(STR_PCIE_ASPM_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_AUTOMATIC), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L0S_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L1_STRING), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_ASPM_L0SL1_STRING), value = 3, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortURE[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_URE_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_URE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortFEE[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_FEE_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_FEE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortNFE[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_NFE_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_NFE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortCEE[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_CEE_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_CEE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSFE[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SFE_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_SFE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSNE[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SNE_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_SNE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortSCE[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_SCE_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_SCE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortPMCE[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_PMCE_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_PMCE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortESE[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_ESE_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_ESE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;


    oneof varid   = Setup.PcieRootPortSpeed[OFFSET_3],
      prompt      = STRING_TOKEN (STR_PCIE_SPEED_PROMPT3),
      help        = STRING_TOKEN (STR_PCIE_SPEED_HELP),
      option text = STRING_TOKEN (STR_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN (STR_GEN1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN (STR_GEN2), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortTHS[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_THS_PROMPT3),
      help        = STRING_TOKEN(STR_PCH_PCIE_THS_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortL1SubStates[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCIE_L1SUB_PROMPT),
      help        = STRING_TOKEN(STR_PCIE_L1SUB_HELP),
     option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
     option text = STRING_TOKEN(STR_PCIE_L1SUB_1_2_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_L1SUB_1_STRING), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCIE_L1SUB_2_STRING), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortNccSsc[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_NCC_SSC_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_NCC_SSC_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PcieRootPortTxEqDeemphSelection[OFFSET_3],
      prompt      = STRING_TOKEN(STR_PCH_PCIE_TXEQDEEMPH_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_TXEQDEEMPH_HELP),
      option text = STRING_TOKEN(STR_DEEMPH_6DB), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED; 
      option text = STRING_TOKEN(STR_DEEMPH_3P5DB), value = 1, flags = RESET_REQUIRED;
    endoneof;

    numeric varid = Setup.PcieExtraBusRsvd[OFFSET_3],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RBUS_PROMPT3),
      help        = STRING_TOKEN (STR_PCH_PCIE_RBUS_HELP),
      minimum     = 0,
      maximum     = 7,
      step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 0,    // default no extra bus reserved
    endnumeric;

    numeric varid = Setup.PcieMemRsvd[OFFSET_3],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RMEM_PROMPT3),
      help        = STRING_TOKEN (STR_PCH_PCIE_RMEM_HELP),
      minimum     = 1,
      maximum     = 20,
      step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 10,   // Default 10MB Memory Reserved
    endnumeric;

    numeric varid = Setup.PcieIoRsvd[OFFSET_3],
      prompt      = STRING_TOKEN (STR_PCH_PCIE_RVIO_PROMPT3),
      help        = STRING_TOKEN (STR_PCH_PCIE_RVIO_HELP),
      minimum     = 4,
      maximum     = 20,
      step        = 4,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 4,    // Default 4K IO Reserved
    endnumeric;

  endif;
endform; //End of PCH_PCIERP4_OPTIONS_FORM_ID

form formid     = PCH_PCIEX_S0IX_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_PCH_PCIEX_S0IX_PROMPT);
    oneof varid   = Setup.PcieS0iX,
      prompt      = STRING_TOKEN(STR_PCI_S0IX_PROMPT),
      help        = STRING_TOKEN(STR_PCI_S0IX_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

  suppressif ideqval Setup.PcieS0iX == 0x0;  
    oneof varid   = Setup.D0S0IxPolicy,
      prompt      = STRING_TOKEN(STR_PCH_PCIE_D0_S0IX_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_D0_S0IX_HELP),
      option text = STRING_TOKEN(STR_D0_S0IX_STRING0), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_D0_S0IX_STRING1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_D0_S0IX_STRING2), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_D0_S0IX_STRING3), value = 3, flags = RESET_REQUIRED;
    endoneof;
    
    oneof varid   = Setup.ClkReqEnable,
      prompt      = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_STS_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_STS_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

  suppressif ideqval Setup.ClkReqEnable == 0x0;
    oneof varid   = Setup.ClkReq,
      prompt      = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_CLKREQ_HELP),
      option text = STRING_TOKEN(STR_CLKREQ_STRING0), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
      option text = STRING_TOKEN(STR_CLKREQ_STRING1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_CLKREQ_STRING2), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_CLKREQ_STRING3), value = 3, flags = RESET_REQUIRED;
    endoneof;
  endif;
  
    oneof varid   = Setup.LtrLatencyScale,
      prompt      = STRING_TOKEN(STR_PCH_PCIE_LTR_LATSC_PROMPT),
      help        = STRING_TOKEN(STR_PCH_PCIE_LTR_LATSC_HELP),
      option text = STRING_TOKEN(STR_LTR_LAT_SCL_STRING0), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_LTR_LAT_SCL_STRING1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_LTR_LAT_SCL_STRING2), value = 2, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
      option text = STRING_TOKEN(STR_LTR_LAT_SCL_STRING3), value = 3, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_LTR_LAT_SCL_STRING4), value = 4, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_LTR_LAT_SCL_STRING5), value = 5, flags = RESET_REQUIRED;      
    endoneof;
    
    numeric varid = Setup.LtrLatencyValue,
      prompt      = STRING_TOKEN (STR_PCH_PCIE_LTR_LATVAL_PROMPT),
      help        = STRING_TOKEN (STR_PCH_PCIE_LTR_LATVAL_HELP),
      minimum     = 1,
      maximum     = 200,
      step        = 1,    // Stepping of 0 equates to a manual entering of a value, otherwise it will auto-increment with a left/right arrow
      default     = 150,   
    endnumeric;
  endif;
endform; //End of PCH_PCIEX_S0IX_OPTIONS_FORM_ID


  
//
// USB Configurations
//
form formid     = USB_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_USB_OPTIONS_FORM_TITLE);
  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  oneof varid   = Setup.PchUsb30Mode,
    prompt      = STRING_TOKEN(STR_PCH_USB30_MODE_PROMPT),
    help        = STRING_TOKEN(STR_PCH_USB30_MODE_HELP),
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
  endoneof;

  suppressif ideqval Setup.PchUsb30Mode == 0;
  suppressif ideqval Setup.BoardId == 0x80; // Refer BOARD_ID_BSW_CH in PlatformInfo.h
    oneof varid   = Setup.PchSsicEnable,
      prompt      = STRING_TOKEN(STR_PCH_SSIC_SUPPORT_PROMPT),
      help        = STRING_TOKEN(STR_PCH_SSIC_SUPPORT_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;
    
    oneof varid   = Setup.PchUsbSsicInitSequence,
      prompt      = STRING_TOKEN(STR_PCH_SSIC_INIT_SEQ_SUPPORT_PROMPT),
      help        = STRING_TOKEN(STR_PCH_SSIC_INIT_SEQ_SUPPORT_HELP),
      option text = STRING_TOKEN(STR_PCH_SSIC_INIT_SEQ_1), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SSIC_INIT_SEQ_2), value = 2, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PchUsbSsicHsRate,
      prompt      = STRING_TOKEN(STR_PCH_SSIC_HSRATE_PROMPT),
      help        = STRING_TOKEN(STR_PCH_SSIC_HSRATE_HELP),
      option text = STRING_TOKEN(STR_PCH_SSIC_HSRATE_A_PROMPT), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_PCH_SSIC_HSRATE_B_PROMPT), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PchUsbSsicPort[0],
      prompt      = STRING_TOKEN(STR_PCH_USB_SSIC_PORT1_PROMPT),
      help        = STRING_TOKEN(STR_PCH_USB_SSIC_PORT1_HELP),
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PchUsbSsicPort[1],
      prompt      = STRING_TOKEN(STR_PCH_USB_SSIC_PORT2_PROMPT),
      help        = STRING_TOKEN(STR_PCH_USB_SSIC_PORT2_HELP),
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PchUsbHsicPort[0],
      prompt      = STRING_TOKEN(STR_PCH_USB_HSIC_PORT1_PROMPT),
      help        = STRING_TOKEN(STR_PCH_USB_HSIC_PORT1_HELP),
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.PchUsbHsicPort[1],
      prompt      = STRING_TOKEN(STR_PCH_USB_HSIC_PORT2_PROMPT),
      help        = STRING_TOKEN(STR_PCH_USB_HSIC_PORT2_HELP),
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    endoneof;
  endif;
  endif;
  oneof varid   = Setup.PchUsb2PhyPgEnabled,
    prompt      = STRING_TOKEN(STR_PCH_USB2_PHY_PG_PROMPT),
    help        = STRING_TOKEN(STR_PCH_USB2_PHY_PG_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_AUTOMATIC), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;

  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  oneof varid   = Setup.PchUsbOtg,
    prompt      = STRING_TOKEN(STR_PCH_USB_OTG_PROMPT),
    help        = STRING_TOKEN(STR_PCH_USB_OTG_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING |  RESET_REQUIRED;
    option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags =RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = RESET_REQUIRED;
  endoneof;

  suppressif TRUE;
    oneof varid   = Setup.PchUsbVbusOn,
      prompt      = STRING_TOKEN(STR_PCH_USB_VBUS_PROMPT),
      help        = STRING_TOKEN(STR_PCH_USB_VBUS_HELP),
#if PPV_ENABLE
      option text = STRING_TOKEN(STR_OFF), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ON), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_AUTO), value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
#else      
      option text = STRING_TOKEN(STR_OFF), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ON), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_AUTO), value = 2, flags = RESET_REQUIRED;
#endif  
    endoneof;
  endif;

endform; // end of USB_OPTIONS_FORM_ID

//
// SATA Configurations
//
form formid = SATA_OPTIONS_FORM_ID,
  title     = STRING_TOKEN(STR_SATA_DEVICE_OPTIONS_FORM_TITLE);

  //
  // Title on SATA Configuration Page
  //
  text
    help   = STRING_TOKEN(STR_NULL_STRING),
    text   = STRING_TOKEN(STR_SATA_DEVICE_OPTIONS_FORM_TITLE),
    text   = STRING_TOKEN(STR_NULL_STRING),
    flags  = 0,
    key    = 0;

  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  oneof varid   = Setup.PchSata,
    prompt      = STRING_TOKEN(STR_PCH_SATA_PROMPT),
    help        = STRING_TOKEN(STR_PCH_SATA_HELP),
#if SATA_SUPPORT
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
#else
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
#endif
  endoneof;

  suppressif ideqval Setup.PchSata == 0;
    oneof varid   = Setup.SataInterfaceMode,
      prompt      = STRING_TOKEN(STR_SATA_MODE_SELECTION_PROMPT),
      help        = STRING_TOKEN(STR_SATA_MODE_SELECTION_HELP),
      option text = STRING_TOKEN(STR_SATA_AHCI), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.SataInterfaceSpeed,
      prompt      = STRING_TOKEN(STR_SATA_INTERFACE_SPEED_PROMPT),
      help        = STRING_TOKEN(STR_SATA_INTERFACE_SPEED_HELP),
      option text = STRING_TOKEN(STR_SATA_SPEED_GEN1), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SATA_SPEED_GEN2), value = 2, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_SATA_SPEED_GEN3), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
   endoneof;

    oneof varid   = Setup.SataTestMode,
      prompt      = STRING_TOKEN(STR_SATA_TEST_MODE_PROMPT),
      help        = STRING_TOKEN(STR_SATA_TEST_MODE_HELP),
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE;
    goto SATA_SFMS_OPTIONS_FORM_ID,
      prompt = STRING_TOKEN(STR_SATA_SFMS_OPTIONS_FORM_TITLE),
      help = STRING_TOKEN(STR_SATA_SFMS_OPTIONS_FORM_HELP);

    oneof varid   = Setup.SataSalp,
      prompt      = STRING_TOKEN(STR_SATA_AHCI_SALP),
      help        = STRING_TOKEN(STR_SATA_AHCI_SALP_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  suppressif NOT ideqval Setup.SataInterfaceMode == SATA_MODE_RAID;
    oneof varid = Setup.SataAlternateId,
      prompt   = STRING_TOKEN(STR_SATA_ALTERNATE_ID_PROMPT),
      help     = STRING_TOKEN(STR_SATA_ALTERNATE_ID_HELP),
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  text
    help   = STRING_TOKEN(STR_EMPTY_STRING),
    text   = STRING_TOKEN(STR_SATA0_STRING),
    text   = STRING_TOKEN(STR_SATA0_NAME),
    flags  = 0,
    key    = 0;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE;
    oneof varid   = Setup.SataPort[OFFSET_0],
      prompt      = STRING_TOKEN(STR_SATA_PORT_0),
      help        = STRING_TOKEN(STR_SATA_PORT_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE OR ideqval Setup.SataExternal[OFFSET_0] == 1;
    oneof varid   = Setup.SataHotPlug[OFFSET_0],
      prompt      = STRING_TOKEN(STR_SATA_HOTPLUG0),
      help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE OR NOT ideqval Setup.SataExternal[OFFSET_0] == 1;
    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_SATA_ESATA),
      text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
      flags  = 0,
      key    = 0;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE OR ideqval Setup.SataHotPlug[OFFSET_0] == 0;
    oneof varid   = Setup.SataMechanicalSw[OFFSET_0],
      prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW0),
      help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE;
    oneof varid   = Setup.SataSpinUp[OFFSET_0],
      prompt      = STRING_TOKEN(STR_SATA_SPIN_UP0),
      help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE;
    oneof varid   = Setup.SataDevSlp[OFFSET_0],
      prompt      = STRING_TOKEN(STR_SATA_DEV_SLP0),
      help        = STRING_TOKEN(STR_SATA_DEV_SLP_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;
  endif;

  text
    help   = STRING_TOKEN(STR_EMPTY_STRING),
    text   = STRING_TOKEN(STR_SATA1_STRING),
    text   = STRING_TOKEN(STR_SATA1_NAME),
    flags  = 0,
    key    = 0;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE;
    oneof varid   = Setup.SataPort[OFFSET_1],
      prompt      = STRING_TOKEN(STR_SATA_PORT_1),
      help        = STRING_TOKEN(STR_SATA_PORT_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE OR ideqval Setup.SataExternal[OFFSET_1] == 1;
    oneof varid   = Setup.SataHotPlug[OFFSET_1],
      prompt      = STRING_TOKEN(STR_SATA_HOTPLUG1),
      help        = STRING_TOKEN(STR_SATA_PORT_HOTPLUG_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE OR NOT ideqval Setup.SataExternal[OFFSET_1] == 1;
    text
      help   = STRING_TOKEN(STR_EMPTY_STRING),
      text   = STRING_TOKEN(STR_SATA_ESATA),
      text   = STRING_TOKEN(STR_SATA_HOTPLUG_SUPPORT),
      flags  = 0,
      key    = 0;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE OR ideqval Setup.SataHotPlug[OFFSET_1] == 0;
    oneof varid   = Setup.SataMechanicalSw[OFFSET_1],
      prompt      = STRING_TOKEN(STR_SATA_MECHANICAL_SW1),
      help        = STRING_TOKEN(STR_SATA_MECHANICAL_SW_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE;
    oneof varid   = Setup.SataSpinUp[OFFSET_1],
      prompt      = STRING_TOKEN(STR_SATA_SPIN_UP1),
      help        = STRING_TOKEN(STR_SATA_SPIN_UP_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.SataInterfaceMode == SATA_MODE_IDE;
    oneof varid   = Setup.SataDevSlp[OFFSET_1],
      prompt      = STRING_TOKEN(STR_SATA_DEV_SLP1),
      help        = STRING_TOKEN(STR_SATA_DEV_SLP_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;
  endif;

endform; // end of SATA_OPTIONS_FORM_ID

form formid     = SATA_SFMS_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_SATA_SFMS_OPTIONS_FORM_TITLE);

  oneof varid   = Setup.SataHddlk,
    prompt      = STRING_TOKEN(STR_PCH_HDDLK_PROMPT),
    help        = STRING_TOKEN(STR_PCH_HDDLK_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;

  oneof varid   = Setup.SataLedl,
    prompt      = STRING_TOKEN(STR_PCH_LEDL_PROMPT),
    help        = STRING_TOKEN(STR_PCH_LEDL_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;

  suppressif NOT ideqval Setup.SataInterfaceMode == SATA_MODE_RAID;
    oneof varid   = Setup.SataRaidR0,
      prompt      = STRING_TOKEN(STR_PCH_RAID0_PROMPT),
      help        = STRING_TOKEN(STR_PCH_RAID0_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.SataRaidR1,
      prompt      = STRING_TOKEN(STR_PCH_RAID1_PROMPT),
      help        = STRING_TOKEN(STR_PCH_RAID1_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.SataRaidR10,
      prompt      = STRING_TOKEN(STR_PCH_RAID10_PROMPT),
      help        = STRING_TOKEN(STR_PCH_RAID10_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.SataRaidR5,
      prompt      = STRING_TOKEN(STR_PCH_RAID5_PROMPT),
      help        = STRING_TOKEN(STR_PCH_RAID5_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.SataRaidIrrt,
      prompt      = STRING_TOKEN(STR_PCH_IRRT_PROMPT),
      help        = STRING_TOKEN(STR_PCH_IRRT_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.SataRaidOub,
      prompt      = STRING_TOKEN(STR_PCH_OUB_PROMPT),
      help        = STRING_TOKEN(STR_PCH_OUB_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.SataRaidIooe,
      prompt      = STRING_TOKEN(STR_PCH_IOOE_PROMPT),
      help        = STRING_TOKEN(STR_PCH_IOOE_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;

  endif;

endform; // End of SATA_SFMS_OPTIONS_FORM_ID

//
// Azalia Configuration
//
form formid     = AZALIA_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_AZALIA_OPTIONS_FORM_TITLE);
  subtitle text = STRING_TOKEN(STR_AZALIA_OPTIONS_FORM_TITLE);

  oneof varid   = Setup.PchLpeEnabled,
    prompt      = STRING_TOKEN(STR_LPE_AUDIO_PROMPT),
    help        = STRING_TOKEN(STR_LPE_AUDIO_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
    option text = STRING_TOKEN(STR_PCI_MODE_STRING), value = 1, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ACPI_MODE_STRING), value = 2, flags = RESET_REQUIRED;
  endoneof;
  
  subtitle text = STRING_TOKEN(STR_NULL_STRING);
  
  oneof varid   = Setup.AudioCodecSuppport,
    prompt      = STRING_TOKEN(STR_AUDIO_CODEC_PROMPT),
    help        = STRING_TOKEN(STR_AUDIO_CODEC_HELP),
    option text = STRING_TOKEN(CODEC_RVP),   value=0, flags= DEFAULT | MANUFACTURING | RESET_REQUIRED;
    option text = STRING_TOKEN(CODEC_EB),    value=1, flags= 0 | RESET_REQUIRED;
  endoneof;
  
  subtitle text = STRING_TOKEN(STR_NULL_STRING);

  suppressif ideqval Setup.AzaliaDs == 0x1;
    oneof varid   = Setup.PchAzalia,
      prompt      = STRING_TOKEN(STR_PCH_AZALIA_PROMPT),
      help        = STRING_TOKEN(STR_PCH_AZALIA_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.AzaliaDs == 0x0;
    text
      help   = STRING_TOKEN(STR_PCH_AZALIA_DS_SUPPORT),
      text   = STRING_TOKEN(STR_PCH_AZALIA_PROMPT),
      text   = STRING_TOKEN(STR_ENABLE),
      flags  = 0,
      key    = 0;
  endif;

  suppressif ideqval Setup.PchAzalia == 0x0;
    oneof varid   = Setup.AzaliaVCiEnable,
      prompt      = STRING_TOKEN(STR_AZALIA_VC_PROMPT),
      help        = STRING_TOKEN(STR_AZALIA_VC_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.PchAzalia == 0x0;
    oneof varid   = Setup.AzaliaDs,
      prompt      = STRING_TOKEN(STR_AZALIA_DS_PROMPT),
      help        = STRING_TOKEN(STR_AZALIA_DS_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = RESET_REQUIRED;
    endoneof;
  endif;

  suppressif ideqval Setup.PchAzalia == 0x0;
    oneof varid   = Setup.AzaliaPme,
      prompt      = STRING_TOKEN(STR_AZALIA_PME_PROMPT),
      help        = STRING_TOKEN(STR_AZALIA_PME_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    oneof varid   = Setup.HdmiCodec,
      prompt      = STRING_TOKEN(STR_HDMI_CODEC_PROMPT),
      help        = STRING_TOKEN(STR_HDMI_CODEC_HELP),
      option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    suppressif ideqval Setup.PchAzalia == 0x0 OR ideqval Setup.HdmiCodec == 0;
      oneof varid   = Setup.HdmiCodecPortB,
        prompt      = STRING_TOKEN(STR_HDMI_CODEC_PORTB_PROMPT),
        help        = STRING_TOKEN(STR_HDMI_CODEC_PORT_HELP),
        option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = Setup.HdmiCodecPortC,
        prompt      = STRING_TOKEN(STR_HDMI_CODEC_PORTC_PROMPT),
        help        = STRING_TOKEN(STR_HDMI_CODEC_PORT_HELP),
        option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = Setup.HdmiCodecPortD,
        prompt      = STRING_TOKEN(STR_HDMI_CODEC_PORTD_PROMPT),
        help        = STRING_TOKEN(STR_HDMI_CODEC_PORT_HELP),
        option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
    endif;
  endif;

endform; // End of AZALIA_OPTIONS_FORM_ID

//
// Security Configuration
//
form formid     = SECURITY_OPTIONS_FORM_ID,
  title         = STRING_TOKEN(STR_SECURITY_OPTIONS_FORM_TITLE);

  oneof varid   = Setup.PchRtcLock,
    prompt      = STRING_TOKEN(STR_PCH_RTC_LOCK_PROMPT),
    help        = STRING_TOKEN(STR_PCH_RTC_LOCK_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags = RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;

  oneof varid   = Setup.PchBiosLock,
    prompt      = STRING_TOKEN(STR_PCH_BLE_PROMPT),
    help        = STRING_TOKEN(STR_PCH_BLE_HELP),
    option text = STRING_TOKEN(STR_DISABLE), value = 0, flags =  RESET_REQUIRED;
    option text = STRING_TOKEN(STR_ENABLE), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
  endoneof;
endform; // End of SECURITY_OPTIONS_FORM_ID
